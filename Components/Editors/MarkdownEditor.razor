@using Squill.Data;
@using Squill.Data.Elements;

<MudItem>
    <EditForm EditContext="m_context">
        <div class="textarea-container @(Minimal ? "textarea-minimal" : "")">
            <div class="page">
                @for (var i = 0; i < m_paragraphs.Count; i++)
                {
                    var paragraph = m_paragraphs[i];
                    <ParagraphDrawer Value=@paragraph.Content
                                     WordStyle="WordStyle"
                                     ValueChanged="(s) => Update(paragraph, s)"
                                     Index=i
                                     OnEnterPressed=Enter
                                     OnBackspaceDelete=Backspace
                                     ForwardParagraph="ForwardParagraph"
                                     BackParagraph="BackParagraph"
                                     CommentAdded="CommentAdded"
                                     CommentsEnabled="CommentsEnabled"
                                     CaretIndex="() => paragraph.CaretIndex"
                                     Focus="() => paragraph.TakeFocus" />
                }
            </div>
        </div>
    </EditForm>
</MudItem>

@code {
    public class Paragraph
    {
        public bool TakeFocus
        {
            get
            {
                if (m_takeFocus)
                {
                    m_takeFocus = false;
                    return true;
                }
                return false;
            }
            set => m_takeFocus = value;
        }
        private bool m_takeFocus;
        public int? CaretIndex { get; set; }
        public string Content { get; set; }
        public override string ToString() => Content;
        public Paragraph(string content, bool takeFocus = false)
        {

            Content = content.Trim();
            TakeFocus = takeFocus;
        }
    }

    [Parameter]
    public new string Value
    {
        get
        {
            return string.Join(Environment.NewLine, m_paragraphs.Select(p => p.Content));
        }
        set
        {
            m_paragraphs = value?.Split(new[] { Environment.NewLine, "\n" }, StringSplitOptions.TrimEntries)
                .Select(p => new Paragraph(p)).ToList() ?? new List<Paragraph> { new Paragraph("", true) };
        }
    }

    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    [Parameter]
    public Func<string, string> WordStyle { get; set; }

    [Parameter]
    public bool Minimal { get; set; }

    [Parameter]
    public bool CommentsEnabled { get; set; }

    [Parameter]
    public EventCallback<Comment> CommentAdded { get; set; }

    private string m_lastValue { get; set; }
    private Task m_autosaveThread { get; set; }
    private List<Paragraph> m_paragraphs = new List<Paragraph>();
    private EditContext m_context;

    protected override void OnInitialized()
    {
        m_lastValue = Value;
        m_autosaveThread = new Task(async () => await AutoSave());
        m_autosaveThread.Start();
        m_context = new EditContext(Value);
    }

    private void Update(Paragraph p, string val)
    {
        p.Content = val;
        if (p.Content.Contains(Environment.NewLine) || p.Content.Contains('\n'))
        {
            var output = Value;
            m_paragraphs = output.Split(new[] { Environment.NewLine, "\n" }, StringSplitOptions.TrimEntries)
                .Select(p => new Paragraph(p)).ToList() ?? new List<Paragraph> { new Paragraph("", true) };
            InvokeAsync(async () => await ValueChanged.InvokeAsync(Value));
        }
    }

    public void Enter(ParagraphDrawer paragraph)
    {
        m_paragraphs[paragraph.Index].Content = m_paragraphs[paragraph.Index].Content?.Trim() ?? string.Empty;
        m_paragraphs.Insert(paragraph.Index + 1, new Paragraph(string.Empty, true));
        StateHasChanged();
        InvokeAsync(async () => await ValueChanged.InvokeAsync(Value));
    }

    public void Backspace(ParagraphDrawer paragraph)
    {
        if (string.IsNullOrEmpty(paragraph.Value))
        {
            m_paragraphs.RemoveAt(paragraph.Index);
            var focus = m_paragraphs.ElementAtOrDefault(paragraph.Index - 1);
            if (focus != null)
            {
                focus.TakeFocus = true;
            }
            StateHasChanged();
            InvokeAsync(async () => await ValueChanged.InvokeAsync(Value));
        }
    }

    private async Task ForwardParagraph(ParagraphDrawer drawer)
    {
        var next = m_paragraphs.ElementAtOrDefault(drawer.Index + 1);
        if (next != null)
        {
            next.TakeFocus = true;
            next.CaretIndex = 0;
            StateHasChanged();
        }
    }

    private async Task BackParagraph(ParagraphDrawer drawer)
    {
        var prev = m_paragraphs.ElementAtOrDefault(drawer.Index - 1);
        if (prev != null)
        {
            prev.TakeFocus = true;
            prev.CaretIndex = int.MaxValue;
            StateHasChanged();
        }
    }

    private async Task AutoSave()
    {
        while (true)
        {
            await Task.Delay(TimeSpan.FromSeconds(10));
            if (m_lastValue == Value)
            {
                continue;
            }
            await InvokeAsync(async () => await ValueChanged.InvokeAsync(Value));
            m_lastValue = Value;
        }
    }
}
