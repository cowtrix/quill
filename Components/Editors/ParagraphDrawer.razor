@using System.Text.Json;
@inject IJSRuntime JS

<div class="grow-wrap text">
    <InputTextArea @onkeydown="@(async (e) => await HandleInput(e))" id="@ID" @ref=Input class="markdown-textfield" @bind-Value=Value @oninput="Update" @onpaste=OnPaste />
    <div class="text">
        @if (WordStyle == null)
        {
            @(Value + " ")
        }
        else if (!string.IsNullOrEmpty(Value))
        {
            @((MarkupString)WordStyle(Value + " "))
        }
    </div>
</div>

@code {

    [CascadingParameter]
    public MarkdownEditor Editor { get; set; }

    [Parameter]
    public string Value
    {
        get => __value.Trim();
        set => __value = value?.Trim() ?? string.Empty;
    }
    private string __value;

    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    [Parameter]
    public int Index { get; set; }

    [Parameter]
    public Func<bool> Focus { get; set; }

    [Parameter]
    public Func<int?> CaretIndex { get; set; }

    [Parameter]
    public EventCallback<ParagraphDrawer> OnEnterPressed { get; set; }

    [Parameter]
    public EventCallback<ParagraphDrawer> OnBackspaceDelete { get; set; }

    [Parameter]
    public EventCallback<ParagraphDrawer> BackParagraph { get; set; }

    [Parameter]
    public EventCallback<ParagraphDrawer> ForwardParagraph { get; set; }

    [Parameter]
    public Func<string, string> WordStyle { get; set; }

    public InputTextArea Input { get; set; }
    public string ID { get; private set; } = Guid.NewGuid().ToString();

    private void Update(ChangeEventArgs args)
    {
        Value = (args.Value as string).Trim();
        InvokeAsync(async () => await ValueChanged.InvokeAsync(Value));
        StateHasChanged();
    }

    private async Task OnPaste(ClipboardEventArgs paste)
    {

    }

    public async Task HandleInput(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            await OnEnterPressed.InvokeAsync(this);
            StateHasChanged();
        }
        if (e.Code == "Backspace" || e.Code == "Delete")
        {
            await OnBackspaceDelete.InvokeAsync(this);
            StateHasChanged();
        }
        if (e.Code.Contains("Arrow"))
        {
            var caret = await JS.InvokeAsync<JsonElement>("getCursorPos", ID);
            var startExists = caret.TryGetProperty("start", out var startJson);
            var endExists = caret.TryGetProperty("end", out var endJson);
            var start = startJson.GetInt32();
            var end = endJson.GetInt32();

            if(start == end)
            {
                if (start == 0 && e.Code == "ArrowLeft")
                {
                    await BackParagraph.InvokeAsync(this);
                }
                if(end >= Value.Length && e.Code == "ArrowRight")
                {
                    await ForwardParagraph.InvokeAsync(this);
                }
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Focus())
        {
            await Input.Element.Value.FocusAsync();
        }
        var caret = CaretIndex();
        if (caret.HasValue)
        {
            await JS.InvokeVoidAsync("setCursorPos", ID, caret.Value);
            CaretIndex = null;
        }
    }
}
